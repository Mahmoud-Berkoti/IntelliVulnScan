import logging
from datetime import datetime
from typing import Dict, List, Any, Optional

from sqlalchemy.orm import Session

from app.models.vulnerability import Vulnerability
from app.schemas.vulnerability import VulnerabilityCreate, VulnerabilityUpdate

logger = logging.getLogger(__name__)


def create_vulnerability(db: Session, vulnerability: VulnerabilityCreate) -> Vulnerability:
    """
    Create a new vulnerability.
    
    Args:
        db: Database session
        vulnerability: Vulnerability data
        
    Returns:
        Created vulnerability
    """
    db_vulnerability = Vulnerability(
        title=vulnerability.title,
        description=vulnerability.description,
        cve_id=vulnerability.cve_id,
        severity=vulnerability.severity,
        cvss_score=vulnerability.cvss_score,
        cvss_vector=vulnerability.cvss_vector,
        asset_id=vulnerability.asset_id,
        scan_id=vulnerability.scan_id,
        status=vulnerability.status,
        exploit_available=vulnerability.exploit_available,
        exploit_maturity=vulnerability.exploit_maturity,
        patch_available=vulnerability.patch_available,
        affected_component=vulnerability.affected_component,
        affected_version=vulnerability.affected_version,
        business_impact=vulnerability.business_impact,
        data_classification=vulnerability.data_classification,
        system_exposure=vulnerability.system_exposure,
        metadata=vulnerability.metadata,
        created_at=datetime.now(),
        updated_at=datetime.now(),
    )
    db.add(db_vulnerability)
    db.commit()
    db.refresh(db_vulnerability)
    logger.info(f"Created vulnerability with ID {db_vulnerability.id}")
    return db_vulnerability


def get_vulnerability(db: Session, vulnerability_id: int) -> Optional[Vulnerability]:
    """
    Get a vulnerability by ID.
    
    Args:
        db: Database session
        vulnerability_id: ID of the vulnerability
        
    Returns:
        Vulnerability if found, None otherwise
    """
    return db.query(Vulnerability).filter(Vulnerability.id == vulnerability_id).first()


def get_vulnerabilities(
    db: Session,
    skip: int = 0,
    limit: int = 100,
    filters: Optional[Dict[str, Any]] = None,
) -> List[Vulnerability]:
    """
    Get vulnerabilities with optional filtering.
    
    Args:
        db: Database session
        skip: Number of records to skip
        limit: Maximum number of records to return
        filters: Optional filters
        
    Returns:
        List of vulnerabilities
    """
    query = db.query(Vulnerability)
    
    if filters:
        if "severity" in filters:
            query = query.filter(Vulnerability.severity == filters["severity"])
        if "status" in filters:
            query = query.filter(Vulnerability.status == filters["status"])
        if "asset_id" in filters:
            query = query.filter(Vulnerability.asset_id == filters["asset_id"])
        if "scan_id" in filters:
            query = query.filter(Vulnerability.scan_id == filters["scan_id"])
        if "cve_id" in filters:
            query = query.filter(Vulnerability.cve_id == filters["cve_id"])
        if "min_cvss" in filters:
            query = query.filter(Vulnerability.cvss_score >= filters["min_cvss"])
        if "max_cvss" in filters:
            query = query.filter(Vulnerability.cvss_score <= filters["max_cvss"])
        if "exploit_available" in filters:
            query = query.filter(Vulnerability.exploit_available == filters["exploit_available"])
        if "patch_available" in filters:
            query = query.filter(Vulnerability.patch_available == filters["patch_available"])
    
    return query.offset(skip).limit(limit).all()


def update_vulnerability(
    db: Session, vulnerability_id: int, vulnerability: VulnerabilityUpdate
) -> Optional[Vulnerability]:
    """
    Update a vulnerability.
    
    Args:
        db: Database session
        vulnerability_id: ID of the vulnerability to update
        vulnerability: Updated vulnerability data
        
    Returns:
        Updated vulnerability if found, None otherwise
    """
    db_vulnerability = get_vulnerability(db, vulnerability_id)
    if not db_vulnerability:
        return None
    
    # Update fields
    for field, value in vulnerability.dict(exclude_unset=True).items():
        setattr(db_vulnerability, field, value)
    
    db_vulnerability.updated_at = datetime.now()
    db.commit()
    db.refresh(db_vulnerability)
    logger.info(f"Updated vulnerability with ID {db_vulnerability.id}")
    return db_vulnerability


def delete_vulnerability(db: Session, vulnerability_id: int) -> bool:
    """
    Delete a vulnerability.
    
    Args:
        db: Database session
        vulnerability_id: ID of the vulnerability to delete
        
    Returns:
        True if deleted, False otherwise
    """
    db_vulnerability = get_vulnerability(db, vulnerability_id)
    if not db_vulnerability:
        return False
    
    db.delete(db_vulnerability)
    db.commit()
    logger.info(f"Deleted vulnerability with ID {vulnerability_id}")
    return True


def update_vulnerability_status(
    db: Session, vulnerability_id: int, status: str, notes: Optional[str] = None
) -> Optional[Vulnerability]:
    """
    Update vulnerability status.
    
    Args:
        db: Database session
        vulnerability_id: ID of the vulnerability
        status: New status
        notes: Optional notes
        
    Returns:
        Updated vulnerability if found, None otherwise
    """
    db_vulnerability = get_vulnerability(db, vulnerability_id)
    if not db_vulnerability:
        return None
    
    db_vulnerability.status = status
    db_vulnerability.updated_at = datetime.now()
    
    if notes:
        if not db_vulnerability.metadata:
            db_vulnerability.metadata = {}
        
        if "status_history" not in db_vulnerability.metadata:
            db_vulnerability.metadata["status_history"] = []
        
        db_vulnerability.metadata["status_history"].append({
            "status": status,
            "timestamp": datetime.now().isoformat(),
            "notes": notes,
        })
    
    db.commit()
    db.refresh(db_vulnerability)
    logger.info(f"Updated vulnerability status to {status} for vulnerability with ID {db_vulnerability.id}")
    return db_vulnerability


def update_vulnerability_priority(
    db: Session, vulnerability_id: int, priority: float, explanation: Optional[Dict[str, Any]] = None
) -> Optional[Vulnerability]:
    """
    Update vulnerability priority.
    
    Args:
        db: Database session
        vulnerability_id: ID of the vulnerability
        priority: New priority score
        explanation: Optional explanation of the priority score
        
    Returns:
        Updated vulnerability if found, None otherwise
    """
    db_vulnerability = get_vulnerability(db, vulnerability_id)
    if not db_vulnerability:
        return None
    
    db_vulnerability.priority = priority
    db_vulnerability.updated_at = datetime.now()
    
    if explanation:
        if not db_vulnerability.metadata:
            db_vulnerability.metadata = {}
        
        db_vulnerability.metadata["priority_explanation"] = explanation
    
    db.commit()
    db.refresh(db_vulnerability)
    logger.info(f"Updated vulnerability priority to {priority} for vulnerability with ID {db_vulnerability.id}")
    return db_vulnerability


def get_vulnerability_details(db: Session, vulnerability_id: int) -> Optional[Dict[str, Any]]:
    """
    Get detailed information about a vulnerability.
    
    Args:
        db: Database session
        vulnerability_id: ID of the vulnerability
        
    Returns:
        Vulnerability details if found, None otherwise
    """
    db_vulnerability = get_vulnerability(db, vulnerability_id)
    if not db_vulnerability:
        return None
    
    # Get asset information
    asset = db_vulnerability.asset
    asset_info = {
        "id": asset.id,
        "name": asset.name,
        "asset_type": asset.asset_type,
        "criticality": asset.criticality,
    } if asset else None
    
    # Get scan information
    scan = db_vulnerability.scan
    scan_info = {
        "id": scan.id,
        "name": scan.name,
        "scanner_type": scan.scanner_type,
        "status": scan.status,
        "created_at": scan.created_at,
    } if scan else None
    
    # Create vulnerability details
    details = {
        "id": db_vulnerability.id,
        "title": db_vulnerability.title,
        "description": db_vulnerability.description,
        "cve_id": db_vulnerability.cve_id,
        "severity": db_vulnerability.severity,
        "cvss_score": db_vulnerability.cvss_score,
        "cvss_vector": db_vulnerability.cvss_vector,
        "status": db_vulnerability.status,
        "priority": db_vulnerability.priority,
        "exploit_available": db_vulnerability.exploit_available,
        "exploit_maturity": db_vulnerability.exploit_maturity,
        "patch_available": db_vulnerability.patch_available,
        "affected_component": db_vulnerability.affected_component,
        "affected_version": db_vulnerability.affected_version,
        "business_impact": db_vulnerability.business_impact,
        "data_classification": db_vulnerability.data_classification,
        "system_exposure": db_vulnerability.system_exposure,
        "created_at": db_vulnerability.created_at,
        "updated_at": db_vulnerability.updated_at,
        "asset": asset_info,
        "scan": scan_info,
        "metadata": db_vulnerability.metadata,
    }
    
    return details 